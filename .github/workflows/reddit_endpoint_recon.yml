name: Reddit Endpoint Monitor

on:
  schedule:
    # run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      domain:
        description: 'Target domain to scan'
        required: true
        default: 'reddit.com'

permissions:
  contents: write

jobs:
  recon:
    runs-on: ubuntu-latest
    env:
      DOMAIN: ${{ github.event.inputs.domain || 'reddit.com' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          clean: true
          fetch-depth: 1

      - name: Set up Go (required >=1.24 for some tools)
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Ensure /usr/local/bin and GOPATH/bin are on PATH
        run: |
          echo "/usr/local/bin" >> $GITHUB_PATH
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
          export PATH="/usr/local/bin:$(go env GOPATH)/bin:$PATH"
          echo "PATH set"

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install Recon Tools (subfinder, katana, gau, waybackurls, gf, httpx)
        run: |
          set -euo pipefail
          echo "[*] Installing Go-based tools into $(go env GOPATH)/bin"

          # discovery & tooling
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

          # katana recommends CGO_ENABLED=1 for some builds; ensure env while installing
          CGO_ENABLED=1 go install -v github.com/projectdiscovery/katana/cmd/katana@latest

          go install -v github.com/lc/gau/v2/cmd/gau@latest
          go install -v github.com/tomnomnom/waybackurls@latest
          go install -v github.com/tomnomnom/gf@latest
          go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest

          echo "[*] Done go installs. Listing $(go env GOPATH)/bin:"
          ls -1 $(go env GOPATH)/bin || true

      - name: Install TruffleHog (official recommended method)
        run: |
          set -euo pipefail
          echo "[*] Installing TruffleHog via official install script to /usr/local/bin"
          # Use the official install script to avoid go module path pitfalls
          curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin || true
          # If curl fails for any reason, try brew (runner supports apt/brew) — best-effort
          if ! command -v trufflehog >/dev/null 2>&1; then
            echo "[!] trufflehog not found after script; attempting to download release binary (best-effort)."
            # fallback: try to fetch latest Linux amd64 release (best-effort, may fail in some runners)
            # Note: this fallback is permissive; if it fails the workflow continues but trufflehog scans will be skipped.
            TG_REPO="https://api.github.com/repos/trufflesecurity/trufflehog/releases/latest"
            LATEST_URL=$(curl -s $TG_REPO | grep browser_download_url | grep linux | head -n1 | cut -d '"' -f4 || true)
            if [ -n "$LATEST_URL" ]; then
              curl -sL "$LATEST_URL" -o /usr/local/bin/trufflehog || true
              chmod +x /usr/local/bin/trufflehog || true
            fi
          fi
          echo "[*] trufflehog version: $(trufflehog --version 2>/dev/null || echo 'trufflehog not installed')"

      - name: Prepare workspace
        run: |
          set -euo pipefail
          mkdir -p results/$DOMAIN
          mkdir -p previous/$DOMAIN
          mkdir -p tmp/$DOMAIN/bodies
          : > results/$DOMAIN/endpoints_raw.txt || true
          : > results/$DOMAIN/interesting_endpoints.txt || true

      - name: Run subfinder
        run: |
          set -euo pipefail
          echo "[*] Running subfinder for $DOMAIN"
          subfinder -d "$DOMAIN" -silent -o results/$DOMAIN/subdomains.txt || true
          sort -u results/$DOMAIN/subdomains.txt -o results/$DOMAIN/subdomains.txt || true
          echo "SUBDOMAINS_COUNT=$(wc -l < results/$DOMAIN/subdomains.txt || echo 0)" >> $GITHUB_ENV
          echo "[*] Subdomains found: $(cat results/$DOMAIN/subdomains.txt || echo '(none)')"

      - name: Enumerate endpoints (gau + katana + waybackurls)
        run: |
          set -euo pipefail
          ENDPOINTS="results/$DOMAIN/endpoints_raw.txt"
          : > "$ENDPOINTS"

          if [ ! -s results/$DOMAIN/subdomains.txt ]; then
            echo "[!] No subdomains found; using root domain for discovery"
            echo "$DOMAIN" > results/$DOMAIN/subdomains.txt
          fi

          while read -r sub; do
            sub="$(echo "$sub" | tr -d '\r')"
            [ -z "$sub" ] && continue
            echo "[+] Enumerating $sub"

            # gau (archival)
            gau "$sub" || true

            # katana (fast crawler). -o - prints to stdout
            katana -u "$sub" -silent -depth 2 -o - || true

            # waybackurls (takes domain on stdin)
            echo "$sub" | waybackurls || true

          done < results/$DOMAIN/subdomains.txt | sort -u >> "$ENDPOINTS" || true

          # normalize
          sort -u "$ENDPOINTS" -o "$ENDPOINTS" || true
          echo "RAW_ENDPOINTS_COUNT=$(wc -l < $ENDPOINTS || echo 0)" >> $GITHUB_ENV
          echo "[*] Collected $(wc -l < $ENDPOINTS || echo 0) raw endpoints."

      - name: Filter interesting endpoints (extensions & keywords)
        run: |
          set -euo pipefail
          RAW="results/$DOMAIN/endpoints_raw.txt"
          FILTERED="results/$DOMAIN/interesting_endpoints.txt"
          : > "$FILTERED"

          # extension-based signal (tweak as you like)
          grep -Ei '\.(js|json|conf|config|env|git|svn|bak|old|zip|tar|gz|7z|sql|log|xml|yml|yaml|txt|backup|swp|php|aspx)$' "$RAW" | sort -u > "$FILTERED" || true

          # keyword-based signal (sensitive names / common config)
          grep -Ei 'backup|wp-config|\.env|credentials|keys|key|secret|token|password' "$RAW" | sort -u >> "$FILTERED" || true

          sort -u "$FILTERED" -o "$FILTERED" || true
          echo "FILTERED_COUNT=$(wc -l < $FILTERED || echo 0)" >> $GITHUB_ENV
          echo "[*] Filtered results: $(wc -l < $FILTERED || echo 0) interesting endpoints."

      - name: Fetch endpoint bodies (best-effort)
        run: |
          set -euo pipefail
          IN_FILE="results/$DOMAIN/interesting_endpoints.txt"
          OUT_DIR="results/$DOMAIN/bodies"
          mkdir -p "$OUT_DIR"
          : > "$OUT_DIR/.fetch_manifest"

          if [ ! -s "$IN_FILE" ]; then
            echo "[!] No interesting endpoints to fetch."
            exit 0
          fi

          count=0
          while read -r url; do
            url="$(echo "$url" | tr -d '\r')"
            [ -z "$url" ] && continue
            safe=$(echo -n "$url" | sha1sum | awk '{print $1}')
            fn="$OUT_DIR/$safe.txt"
            # quick content-type check via httpx to skip big binaries if httpx exists
            if command -v httpx >/dev/null 2>&1; then
              # get status and content-type quickly; if content-length too large skip (not perfect)
              CT=$(echo "$url" | httpx -silent -status-code -content-type -response -timeout 10 2>/dev/null | awk -F'|' '{print $3}' | head -n1 || true)
            fi
            # fetch the body (short timeouts), ignore certs, follow redirects
            if curl -L --max-time 15 --connect-timeout 5 -sS -k "$url" -o "$fn"; then
              echo "$url|$fn" >> "$OUT_DIR/.fetch_manifest"
              count=$((count+1))
            else
              echo "$url|FAILED" >> "$OUT_DIR/.fetch_manifest"
            fi
          done < "$IN_FILE"

          echo "BODY_FILES_FETCHED=$count" >> $GITHUB_ENV
          echo "[*] Fetched $count endpoint bodies (best-effort)."

      - name: Run trufflehog secret scan on fetched bodies (if available)
        run: |
          set -euo pipefail
          BODIES_DIR="results/$DOMAIN/bodies"
          OUT_JSON="results/$DOMAIN/secrets_trufflehog.json"
          mkdir -p results/$DOMAIN
          if command -v trufflehog >/dev/null 2>&1 && [ -d "$BODIES_DIR" ] && [ "$(ls -A "$BODIES_DIR" | wc -l)" -gt 0 ]; then
            echo "[*] Running trufflehog filesystem scan against $BODIES_DIR"
            # filesystem scan outputs JSON lines; capture into file
            trufflehog filesystem --path "$BODIES_DIR" --json > "$OUT_JSON" || true
            echo "[*] Trufflehog results saved to $OUT_JSON"
          else
            if ! command -v trufflehog >/dev/null 2>&1; then
              echo "[!] trufflehog not installed, skipping secret scan."
            else
              echo "[*] No fetched bodies to scan."
            fi
            : > "$OUT_JSON"
          fi

      - name: Compare filtered endpoints with previous run
        id: compare
        run: |
          set -euo pipefail
          CUR="results/$DOMAIN/interesting_endpoints.txt"
          PREV="previous/$DOMAIN/interesting_endpoints.txt"
          mkdir -p previous/$DOMAIN
          : > results/$DOMAIN/new_endpoints.txt
          : > results/$DOMAIN/removed_endpoints.txt

          if [ -f "$PREV" ]; then
            comm -23 <(sort "$CUR") <(sort "$PREV") > results/$DOMAIN/new_endpoints.txt || true
            comm -13 <(sort "$CUR") <(sort "$PREV") > results/$DOMAIN/removed_endpoints.txt || true
            echo "NEW_COUNT=$(wc -l < results/$DOMAIN/new_endpoints.txt || echo 0)" >> $GITHUB_ENV
            echo "REMOVED_COUNT=$(wc -l < results/$DOMAIN/removed_endpoints.txt || echo 0)" >> $GITHUB_ENV
          else
            # first run: treat all as new and seed previous
            cp -f "$CUR" "$PREV" || true
            echo "NEW_COUNT=$(wc -l < $CUR || echo 0)" >> $GITHUB_ENV
            echo "REMOVED_COUNT=0" >> $GITHUB_ENV
            cp -f "$CUR" results/$DOMAIN/new_endpoints.txt || true
          fi

      - name: Save artifacts (results)
        uses: actions/upload-artifact@v4
        with:
          name: recon-results-${{ env.DOMAIN }}-${{ github.run_id }}
          path: |
            results/${{ env.DOMAIN }}/
            results/${{ env.DOMAIN }}/interesting_endpoints.txt
            results/${{ env.DOMAIN }}/endpoints_raw.txt
            results/${{ env.DOMAIN }}/new_endpoints.txt
            results/${{ env.DOMAIN }}/removed_endpoints.txt
            results/${{ env.DOMAIN }}/secrets_trufflehog.json
            results/${{ env.DOMAIN }}/bodies/
          retention-days: 7

      - name: Commit updated previous results (so next run can diff)
        run: |
          set -euo pipefail
          mkdir -p previous/$DOMAIN
          cp -f results/$DOMAIN/interesting_endpoints.txt previous/$DOMAIN/interesting_endpoints.txt || true
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add previous/$DOMAIN/interesting_endpoints.txt || true
          if git diff --staged --quiet; then
            echo "[*] No changes to previous endpoints to commit."
          else
            git commit -m "chore(recon): update previous endpoints for $DOMAIN"
            # best-effort push — runner must have write permission
            git push origin HEAD:main || echo "[!] Push failed (check permissions/branch and token)"
          fi

      - name: Notify via webhook if changes detected (optional)
        if: env.NEW_COUNT != '0' || env.REMOVED_COUNT != '0'
        env:
          WEBHOOK_URL: ${{ secrets.REDDIT_DISCORD }}  # set this secret in repo Settings -> Secrets
        run: |
          set -euo pipefail
          NEW=$(cat results/$DOMAIN/new_endpoints.txt | wc -l || echo 0)
          REMOVED=$(cat results/$DOMAIN/removed_endpoints.txt | wc -l || echo 0)
          NEW_EXAMPLES=$(head -n 10 results/$DOMAIN/new_endpoints.txt | sed ':a;N;$!ba;s/\n/\\n/g' || echo "None")
          REMOVED_EXAMPLES=$(head -n 10 results/$DOMAIN/removed_endpoints.txt | sed ':a;N;$!ba;s/\n/\\n/g' || echo "None")
          PAYLOAD=$(jq -n \
            --arg title "Recon changes for $DOMAIN" \
            --arg new_count "$NEW" \
            --arg removed_count "$REMOVED" \
            --arg new_examples "$NEW_EXAMPLES" \
            --arg removed_examples "$REMOVED_EXAMPLES" \
            '{
              "embeds": [{
                "title": $title,
                "color": 16753920,
                "fields": [
                  {"name":"New endpoints","value":$new_count,"inline":true},
                  {"name":"Removed endpoints","value":$removed_count,"inline":true},
                  {"name":"New examples (first 10)","value":$new_examples,"inline":false},
                  {"name":"Removed examples (first 10)","value":$removed_examples,"inline":false}
                ],
                "footer": {"text":"Recon Endpoint Monitor"}
              }]
            }')
          if [ -n "${WEBHOOK_URL:-}" ]; then
            curl -H "Content-Type: application/json" -d "$PAYLOAD" "$WEBHOOK_URL" || true
          else
            echo "[!] No WEBHOOK_URL secret configured; skipping notification."
          fi

      - name: Cleanup (optional)
        if: always()
        run: |
          rm -rf tmp || true
